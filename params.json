{"name":"hlld","tagline":"A high performance C server for HyperLogLogs","body":"hlld [![Build Status](https://travis-ci.org/armon/hlld.png?branch=master)](https://travis-ci.org/armon/hlld)\r\n=========\r\n\r\nhlld is a high-performance C server which is used\r\nto expose HyperLogLog sets and operations over them to\r\nnetworked clients. It uses a simple ASCI protocol\r\nwhich is human readable, and similar to memcached.\r\n\r\nFeatures\r\n--------\r\n\r\n* Scalable non-blocking core allows for many connected\r\n  clients and concurrent operations\r\n* Implements 6bit wide HyperLogLogs, allowing almost unbounded counts\r\n* Supports asynchronous flushes to disk for persistence\r\n* Supports non-disk backed sets for high I/O\r\n* Automatically faults cold sets out of memory to save resources\r\n* Dead simple to start and administer\r\n* FAST, FAST, FAST\r\n\r\nInstall\r\n-------\r\n\r\nDownload and build from source:\r\n\r\n    $ git clone https://armon@github.com/armon/hlld.git\r\n    $ cd hlld\r\n    $ pip install SCons  # Uses the Scons build system, may not be necessary\r\n    $ scons\r\n    $ ./hlld\r\n\r\nThis will generate some errors related to building the test code\r\nas it depends on libcheck. To build the test code successfully,\r\ndo the following:\r\n\r\n    $ cd deps/check-0.9.8/\r\n    $ ./configure\r\n    $ make\r\n    # make install\r\n    # ldconfig (necessary on some Linux distros)\r\n\r\nThen re-build hlld. At this point, the test code should build\r\nsuccessfully.\r\n\r\nUsage\r\n-----\r\n\r\nhlld can be configured using a file which is in INI format.\r\nHere is an example configuration file:\r\n\r\n    # Settings for hlld\r\n    [hlld]\r\n    tcp_port = 4553\r\n    udp_port = 4554\r\n    data_dir = /mnt/hlld\r\n    log_level = INFO\r\n    cold_interval = 3600\r\n    flush_interval = 60\r\n    default_eps = 0.02\r\n    workers = 2\r\n\r\n\r\nThen run hlld, pointing it to that file:\r\n\r\n    hlld -f /etc/hlld.conf\r\n\r\nProtocol\r\n--------\r\n\r\nBy default, hlld will listen for TCP connections on port 4553.\r\nIt uses a simple ASCII protocol that is very similar to memcached.\r\n\r\nA command has the following syntax::\r\n\r\n    cmd [args][\\r]\\n\r\n\r\nWe start each line by specifying a command, providing optional arguments,\r\nand ending the line in a newline (carriage return is optional).\r\n\r\nThere are a total of 9 commands:\r\n\r\n* create - Create a new set (a set is a named HyperLogLog)\r\n* list - List all sets\r\n* drop - Drop a set (Deletes from disk)\r\n* close - Closes a set (Unmaps from memory, but still accessible)\r\n* clear - Clears a set from the lists (Removes memory, left on disk)\r\n* set|s - Set an item in a set\r\n* bulk|b - Set many items in a set at once\r\n* info - Gets info about a set\r\n* flush - Flushes all sets or just a specified one\r\n\r\nFor the ``create`` command, the format is::\r\n\r\n    create set_name [precision=prec] [eps=max_eps] [in_memory=0|1]\r\n\r\nWhere ``set_name`` is the name of the set,\r\nand can contain the characters a-z, A-Z, 0-9, ., _.\r\nIf a precision is provided the set\r\nwill be created with the given bits of precision, otherwise the configured default value will be used.\r\nIf a maximum epsilon is provided, that will be used to compute a precision, otherwise the configured default is used.\r\nYou can optionally specify in_memory to force the set to not be persisted to disk. If both precision and\r\neps are specified, it is not specified which one will be used. Generally, only one should be provided,\r\nas the other will be computed.\r\n\r\nAs an example::\r\n\r\n    create foobar eps=0.01\r\n\r\nThis will create a set foobar that has a maximum variance of 1%.\r\nValid responses are either \"Done\", \"Exists\", or \"Delete in progress\". The last response\r\noccurs if a set of the same name was recently deleted, and hlld\r\nhas not yet completed the delete operation. If so, a client should\r\nretry the create in a few seconds.\r\n\r\nThe ``list`` command takes no arguments, and returns information\r\nabout all the sets. Here is an example response::\r\n\r\n    START\r\n    foobar 0.010000 14 13108 0\r\n    END\r\n\r\nThis indicates a single set named foobar, with a variance\r\nof 0.02, precision 12, a 4096 byte size, a current size estimate of 1540\r\nitems.\r\n\r\nThe ``drop``, ``close`` and ``clear`` commands are like create, but only takes a set name.\r\nIt can either return \"Done\" or \"Set does not exist\". ``clear`` can also return \"Set is not proxied. Close it first.\".\r\nThis means that the set is still in-memory and not qualified for being cleared.\r\nThis can be resolved by first closing the set.\r\n\r\nset is a very simple command:\r\n\r\n    set set_name key\r\n\r\nThe command must specify a set and a key to use.\r\nIt will either return \"Done\", or \"Set does not exist\".\r\n\r\nThe bulk command is similar to set but allows for many keys\r\nto be set at once. Keys must be separated by a space:\r\n\r\n    bulk set_name key1 [key_2 [key_3 [key_N]]]\r\n\r\nThe bulk and set commands can also be called by their aliasses\r\nb and s respectively.\r\n\r\nThe ``info`` command takes a set name, and returns\r\ninformation about the set. Here is an example output:\r\n\r\n    START\r\n    in_memory 1\r\n    page_ins 0\r\n    page_outs 0\r\n    eps 0.02\r\n    precision 12\r\n    sets 0\r\n    size 1540\r\n    storage 3280\r\n    END\r\n\r\nThe command may also return \"Set does not exist\" if the set does\r\nnot exist.\r\n\r\nThe ``flush`` command may be called without any arguments, which\r\ncauses all sets to be flushed. If a set name is provided\r\nthen that set will be flushed. This will either return \"Done\" or\r\n\"Set does not exist\".\r\n\r\nExample\r\n----------\r\n\r\nHere is an example of a client flow, assuming hlld is\r\nrunning on the default port using just telnet::\r\n\r\n    $ telnet localhost 4553\r\n    > list\r\n    START\r\n    END\r\n\r\n    > create foobar\r\n    Done\r\n\r\n    > set foobar zipzab\r\n    Done\r\n\r\n    > bulk foobar zipzab blah boo\r\n    Done\r\n\r\n    > list\r\n    START\r\n    foobar 0.016250 12 3280 3\r\n    END\r\n\r\n    > drop foobar\r\n    Done\r\n\r\n    > list\r\n    START\r\n    END\r\n\r\n\r\nClients\r\n----------\r\n\r\nHere is a list of known client implementations:\r\n\r\n* WIP...\r\n\r\nHere is a list of \"best-practices\" for client implementations:\r\n\r\n* Maintain a set of open connections to the server to minimize connection time\r\n* Make use of the bulk operations when possible, as they are more efficient.\r\n* For long keys, it is better to do a client-side hash (SHA1 at least), and send\r\n  the hash as the key to minimize network traffic.\r\n\r\n\r\nPerformance\r\n-----------\r\n\r\nAlthough extensive performance evaluations have not been done,\r\ncasual testing on a 2012 MBP with pure set operations\r\nallows for a throughput of at least 1MM ops/sec. On Linux,\r\nresponse times can be as low as 1 Î¼s.\r\n\r\nhlld also supports multi-core systems for scalability, so\r\nit is important to tune it for the given work load. The number\r\nof worker threads can be configured either in the configuration\r\nfile, or by providing a `-w` flag. This should be set to at most\r\n2 * CPU count. By default, only a single worker is used.\r\n\r\n\r\nReferences\r\n-----------\r\n\r\nHere are some related works which we make use of:\r\n\r\n* HyperLogLog in Practice: Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm : http://research.google.com/pubs/pub40671.html\r\n* HyperLogLog: The analysis of a near-optimal cardinality estimation algorithm : http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.142.9475\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}